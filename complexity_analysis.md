# A Gentle Introduction to Algorithm Complexity Analysis
> 这是一篇来自希腊的教育文章,这个人喜欢摄影并且我给了它我拍摄的国内照片
## 介绍(introduction)
> 介绍了此文章针对什么样的人,读完文章之后你可以获得什么
- purpose after reading the article  
   - 应该能够应用它到自己的代码中
   - 理解大O表示法
   - 渐进式行为
   - 最坏情况分析

## 动机(motivation)
> 计算出一个程序运行的有多快,不管他用了什么语言,运行在什么平台和硬件中

- 算法(what)
> 复杂度分析到底在分析的是什么,分析的就是此程序计算(+-*/搜索,在一个人工智能的游戏中确定一个任务走过的路径(映射在游戏中的)等)的能力
重点就是计算这个词,计算这个,计算那个都属于计算;
```html
As algorithms are programs that perform just a computation, 
and not other things computers often do 
such as `networking tasks` or user `input and output`, 
complexity analysis allows us to measure how fast a program is when it performs computation
```
- 复杂度分析
> 复杂度分析就是一个巨大输入的时候,来解释这个这个算法(计算能力)是怎么样的;

## 例子(example)
- 计算介绍(counting instruction)
> 从一个数组中找到maximum value

```javascript
var M = A[ 0 ];
 
for ( var i = 0; i < n; ++i ) {
if ( A[ i ] >= M ) {
M = A[ i ];
}
}
```
步骤(step/stage):
- 复制给一个变量 M=A[0]
- 循环之前 把0 assign i  ==> i =0
- 比较i 和 n 的value i ==> i < n 
- if else 不执行
- 循环之后 i 增加 i++
- i < n 再次比较 

可以在忽略循环体的时候and 把2和3,5和6 * n ,可以计算得出计算执行的指令是4n+2,现在看看我们的循环体,我们发现循环体
中的指令有可能run有可能不run,在分析算法的时候能我们通常考虑最坏的情况,假设这个循环体总是执行,最后我们得到算法的指令
数是 fn=4n + 2 + 2n ===> fn = 6n + 2

`总结:` 分析一个循环的算法步骤
1. 忽略循环体,考虑循环之前和之后的执行指令数
2. 计算循环体,如果循环体的指令书不能确定,考虑最坏的情况
3. 两者相加就是我们的总指令数 

## 渐进式行为
我们的指令数是fn = 6n + 2,我们发现当n的输入变得越来越大的时候,6n这项变得越来越大,并且增长的很快,然而2不变或者说它增长
缓慢,要远远的小于6n这项,这种过滤调其他因素,保持这个变化的最大项称之为渐进式行为

`总结:`通过上面我们最终得到我们的指令数fn=n

## 一些通常计算指令数的例子
- 在一个n的数组中找出一个特定存在的值,fn=n
- 两层循环(判断两个数组中时候有相同的元素) fn=n2
- 一层循环调用一个方法,如果我们知道这个函数的指令数,我们就能够很好的计算,如果方法是fn=n,哪么这个程序的指令数就是fn=n2
- 两个嵌套的循环跟着一个单一的循环,他的指令和单一的嵌套循环是一样的,这就是渐进行为得出的结论

### 计算机科学中使用的符号
- Θ(f(n))当我们能够`actual`找出一个程序的渐进式的时候,我们就说我们的程序就是Θ(n)这个n就是时间复杂度或者是说是算法的复杂度
> 注意这个精确单词,这个notation就是可以精确找出这个指令数 
- Big-O notation
> 有时我们很难的去找出一个算法精确的复杂度,这种情况我们可以说这个算法不会超过一个确定的边界,可以用大O表示法

```java
// 我们各一个数组排序
// 两层循环,外层为n
// 内层1 + 2 + ... + (n - 1) + n
```
> 这是非常难的去得到结果,这种情况我们可以修改一下程序让程序变得更糟糕,但是很方便的计算我们的复杂度,此时我们可以假设内层循环总是
>去执行n次,那么这个算法的复杂度就是fn=n2,我们就可以说这个算法复杂度的情况不会币fn=n2更糟糕

`总结:` 大O表示发表示的就是我们程序的复杂度不会比这个更糟糕
- made between

分析

